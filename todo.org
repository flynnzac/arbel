* CANCELLED Add ability to switch output from screen to also write to file
  CLOSED: [2019-08-21 Wed 18:11]

  - State "CANCELLED"  from "TODO"       [2019-08-21 Wed 18:11] \\
    Don't think this is as useful as I though, should just have a logging function
* DONE File input / a File datatype
  CLOSED: [2019-08-15 Thu 12:08]

* DONE More convenient file input (currently just have the bare minimum to make it work: read character-by-character.)
  CLOSED: [2019-08-17 Sat 17:11]
** DONE Add read-line
   CLOSED: [2019-08-16 Fri 14:48]
** TODO Add write/write-line
** TODO Add Perl-ish "slurp"
* DONE Documentation: Better explanation of how substatements work in the docs/how the system uses the ans register.
  CLOSED: [2019-08-21 Wed 18:11]
* DONE OR/AND/NOT
  CLOSED: [2019-08-15 Thu 12:08]
* DONE Any error should stop whole instruction
  CLOSED: [2019-08-16 Fri 14:48]
* DONE Segfault when trying to go-in a nonexistent ref
  CLOSED: [2019-08-16 Fri 14:48]
* DONE Someway to easily move data from one environment to another.
  CLOSED: [2019-08-17 Sat 17:11]

Probably something like

in \reg1 ( set $buffer [ get $#key1 \my-data . ] . ) $my-data \reg2 .

It's probably easier to just have

set REGISTER VALUE REGISTRY .
as an option

* DONE Consider whether want [ instruction ] to run in new registry (I think so)
  CLOSED: [2019-08-21 Wed 17:49]

Implemented

* TODO Have a for loop.  It's basically just some sugar for the while statement, but do it because very common.

Idea would be:

for REGISTER VALUE INSTRUCTION1 INSTRUCTION2 INSTRUCTION3

Where: 

REGISTER is the register that is being iterated
VALUE is the initial value of the register
INSTRUCTION1 is the instruction to execute that sets the ans register to the next value.  
INSTRUCTION2 is the instruction to execute to see if we should continue (set ans to 1 if yes, 0 if no)
INSTRUCTION3 is the body of the loop

So:

for $i $#1 ( next \i . ) ( exist-in \i \reg . ) ( print \i . ) .





* DONE Add a way to call shell
  CLOSED: [2019-08-21 Wed 18:11]

Some instruction like "shell"

shell STRING .

Executes a command

returns any output as string.

* DONE Add a way to accept user input interactively
  CLOSED: [2019-08-18 Sun 12:39]

Thinking 

input $register .

Takes input and assigns it to register.

* TODO A parse function that turns a string into a parsed object

This can basically be satisfied by having a "parse object" function in parse.c

Want to have a generic:

parse "'Hello'" . => "Hello"

parse "1" . => 2




* TODO Handle () code better

( CODE ) should not just be re-interpreted repeatedly

It seems like the obvious series of things to execute is:

INSTRUCTION ARG1 ARG2 ... ARGN .

Becomes:

new registry. ans =
#0 = INSTRUCTION 
#1 = ARG1
#2 = ARG2
...
#N = ARGN
up = current-context

Then call compute on that registry.

So we should have a function that does this from a statement.

set $addone ( add #1 1 . print ans . )

Should have the following pass:

addone = Array of Statements

Statement 1: 
add
lookup(#1)
literal(1)

Statement 2:
print
lookup(ans)

Then when: addone 2 .

Create registry:
Set: #0 addone
Set: #1 2
Execute Statement 1 in this registry.
Execute Statement 2 in this registry.



If we had used references


** DONE 1: malloc_consolidate(): invalid chunk
   CLOSED: [2019-08-22 Thu 23:12]

source "factorial.arb" .
factorial 5 .
factorial 4 .

** DONE 2: while needs to be re-instated
   CLOSED: [2019-08-23 Fri 01:27]

** DONE 3: Need to be able to enter multi-line code on prompt again
   CLOSED: [2019-08-23 Fri 01:27]

** DONE 4: Memory-management for instructions and statement structures
   CLOSED: [2019-08-23 Fri 01:27]

** TODO 5: Execute each statement in its own registry



