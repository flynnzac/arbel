* CANCELLED Add ability to switch output from screen to also write to file
  CLOSED: [2019-08-21 Wed 18:11]

  - State "CANCELLED"  from "TODO"       [2019-08-21 Wed 18:11] \\
    Don't think this is as useful as I though, should just have a logging function
* DONE File input / a File datatype
  CLOSED: [2019-08-15 Thu 12:08]

* DONE More convenient file input (currently just have the bare minimum to make it work: read character-by-character.)
  CLOSED: [2019-08-17 Sat 17:11]
** DONE Add read-line
   CLOSED: [2019-08-16 Fri 14:48]
** TODO Add write/write-line
** TODO Add Perl-ish "slurp"
* DONE Documentation: Better explanation of how substatements work in the docs/how the system uses the ans register.
  CLOSED: [2019-08-21 Wed 18:11]
* DONE OR/AND/NOT
  CLOSED: [2019-08-15 Thu 12:08]
* DONE Any error should stop whole instruction
  CLOSED: [2019-08-16 Fri 14:48]
* DONE Segfault when trying to go-in a nonexistent ref
  CLOSED: [2019-08-16 Fri 14:48]
* DONE Someway to easily move data from one environment to another.
  CLOSED: [2019-08-17 Sat 17:11]

Probably something like

in \reg1 ( set $buffer [ get $#key1 \my-data . ] . ) $my-data \reg2 .

It's probably easier to just have

set REGISTER VALUE REGISTRY .
as an option

* DONE Consider whether want [ instruction ] to run in new registry (I think so)
  CLOSED: [2019-08-21 Wed 17:49]

Implemented

* CANCELLED Have a for loop.  It's basically just some sugar for the while statement, but do it because very common.
  CLOSED: [2019-09-11 Wed 08:18]



  - State "CANCELLED"  from "TODO"       [2019-09-11 Wed 08:18] \\
    Purpose accomplished by the repeat instruction
Idea would be:

for REGISTER VALUE INSTRUCTION1 INSTRUCTION2 INSTRUCTION3

Where: 

REGISTER is the register that is being iterated
VALUE is the initial value of the register
INSTRUCTION1 is the instruction to execute that sets the ans register to the next value.  
INSTRUCTION2 is the instruction to execute to see if we should continue (set ans to 1 if yes, 0 if no)
INSTRUCTION3 is the body of the loop

So:

for $i $#1 ( next \i . ) ( exist-in \i \reg . ) ( print \i . ) .





* DONE Add a way to call shell
  CLOSED: [2019-08-21 Wed 18:11]

Some instruction like "shell"

shell STRING .

Executes a command

returns any output as string.

* DONE Add a way to accept user input interactively
  CLOSED: [2019-08-18 Sun 12:39]

Thinking 

input $register .

Takes input and assigns it to register.

* TODO A parse function that turns a string into a parsed object

This can basically be satisfied by having a "parse object" function in parse.c

Want to have a generic:

parse "'Hello'" . => "Hello"

parse "1" . => 2




* DONE Handle () code better
  CLOSED: [2019-08-24 Sat 02:53]

( CODE ) should not just be re-interpreted repeatedly

It seems like the obvious series of things to execute is:

INSTRUCTION ARG1 ARG2 ... ARGN .

Becomes:

new registry. ans =
#0 = INSTRUCTION 
#1 = ARG1
#2 = ARG2
...
#N = ARGN
up = current-context

Then call compute on that registry.

So we should have a function that does this from a statement.

set $addone ( add #1 1 . print ans . )

Should have the following pass:

addone = Array of Statements

Statement 1: 
add
lookup(#1)
literal(1)

Statement 2:
print
lookup(ans)

Then when: addone 2 .

Create registry:
Set: #0 addone
Set: #1 2
Execute Statement 1 in this registry.
Execute Statement 2 in this registry.



If we had used references


** DONE 1: malloc_consolidate(): invalid chunk
   CLOSED: [2019-08-22 Thu 23:12]

source "factorial.arb" .
factorial 5 .
factorial 4 .

** DONE 2: while needs to be re-instated
   CLOSED: [2019-08-23 Fri 01:27]

** DONE 3: Need to be able to enter multi-line code on prompt again
   CLOSED: [2019-08-23 Fri 01:27]

** DONE 4: Memory-management for instructions and statement structures
   CLOSED: [2019-08-23 Fri 01:27]

** DONE 5: Execute each statement in its own registry
   CLOSED: [2019-08-23 Fri 18:33]

** DONE 6: "ans" register doesn't get looked up in integral.arb (works if you store ans somewhere else)
   CLOSED: [2019-08-24 Sat 02:44]

** DONE 7: get save/load working again
   CLOSED: [2019-08-24 Sat 02:52]


* DONE Clean up error-handling with new parsing strategy
  CLOSED: [2019-08-25 Sun 02:46]

* DONE Add more basic math functions (log, exp, to-power)
  CLOSED: [2019-09-11 Wed 08:17]

* DONE Reduce unnecessary copying (thinking first for literals because that is mostly a change in basic memory management) 
  CLOSED: [2019-09-11 Wed 08:17]

* DONE Add c for new comment notation to doc
  CLOSED: [2019-08-27 Tue 23:51]
* TODO An operation that does nothing but "lookup" all arguments.  To evaluate active instructions. `sit` is a good candidate
* DONE Add regular expression function
  CLOSED: [2019-08-30 Fri 16:52]
`match` should give a registry of registries with each subregistry containing a different match.  Currently, it is just matching once.

Should add a substitute method.

Something like:

replace-one REGEX STRING . (replace first occurence in string)

* DONE Issue with parenthesis in quote expressions with parser
  CLOSED: [2019-08-28 Wed 13:23]


* DONE Add equivalent versions of assign which do not allocate but simply assume the memory has been allocated.  Will make many basic ops more efficient
  CLOSED: [2019-09-11 Wed 08:19]
* DONE Split out escaping strings from assigning strings.  Just an argument to copy.
  CLOSED: [2019-08-30 Fri 16:52]
* DONE Should be able to pre-allocate and hash names for registries of statements.  There are a fixed number of arguments, no reason it couldn't be done ahead of time.  Would make functions/loops faster.
  CLOSED: [2019-09-01 Sun 15:34]
* DONE Performance improvements
  CLOSED: [2019-09-02 Mon 21:59]
** DONE Registers/References can be hashed at allocation and copied without calling hash_str again
   CLOSED: [2019-09-02 Mon 02:09]
** DONE Hash element names before calling statements
   CLOSED: [2019-09-02 Mon 03:39]
** DONE Instructions at #0 should not be copied to new registry
   CLOSED: [2019-09-02 Mon 03:39]
** DONE If register already exists, do not delete it.  Just replace its data.
   CLOSED: [2019-09-02 Mon 03:39]
** TODO do-to-all, join, collapse all look really inefficient compared to what they could be
* DONE After performance improvements, looks like some difficulty retrieving references to \#1 etc throughout an instruction.
  CLOSED: [2019-09-02 Mon 21:59]
* DONE Comment settled as *, switch from ! because might be useful for "modification syntax"
  CLOSED: [2019-09-02 Mon 22:00]
* DONE Switched to ' for comment because might want to use * for some sort of globbing thing.  
  CLOSED: [2019-09-02 Mon 22:16]

* DONE Create a convenient syntax for accessing registers in registries
  CLOSED: [2019-09-03 Tue 16:32]

Current idea is the syntax: 

REGISTRY/REGISTER

If register is a REGISTRY itself, then

REGISTRY/REGISTER/REGISTER 

should work

Settled on

REGISTRY:REGISTER

for aesthetic reasons


* DONE Write the access notation for registries so that it is more "programmatic".
  CLOSED: [2019-09-03 Tue 21:59]

i.e. expect registers as values.  Some will be literal registers and others will not lookup values that (presumably) return registers.  We should keep this part "syntax" rather than language so don't allow substatemets or anything crazy but:

set @i @#1 .
add A:i 1 .


* DONE I actually like / so keep it
  CLOSED: [2019-09-03 Tue 21:59]

* DONE Make references work with slash notation
  CLOSED: [2019-09-04 Wed 17:57]
* DONE Decision not to make registers "work" with slash notation
  CLOSED: [2019-09-04 Wed 17:57]

I considered beig able to reference registers in the following way,

set @A/@#1/@#2 5 .

Instead, I decided to keep it like this:

set @#2 5 \A/@#1 .

Much simpler to understand (a register literal has no inherent context).
* DONE Document slash notation
  CLOSED: [2019-09-10 Tue 23:58]
** DONE Important to note how this allows for "namespaces"
   CLOSED: [2019-09-10 Tue 23:59]

Like so,

set @namespace [ reg . ] .
set @func1 ( ... ) \namespace .
* DONE Decide whether to use #1 or _1 or similar
  CLOSED: [2019-09-04 Wed 23:35]
@#1 #1 - stick with this
@_1 _1
@:1 :1 
@1- 1-
@=1 =1
@$1 $1
@*1 *1
@,1 ,1
@~1 ~1
* DONE Really need to clean up do-to-all, join, collapse, next code.  It's bad.
  CLOSED: [2019-09-11 Wed 08:17]
* TODO Do another efficiency pass
* DONE An "of" and "isof" typing system?
  CLOSED: [2019-12-02 Mon 00:15]
* DONE Consider whether we want to reserve register type with post-sigils
  CLOSED: [2019-12-02 Mon 00:15]

Like so:

a string = :string$
a registry = :registry@
an integer = :integer#
a decimal - :decimal%
an instruction = :instruction
a file = :file_
a register = :register:

No, I don't like this.
* DONE Remove data and up registers.  Think of a better way to get that feature.
  CLOSED: [2019-09-11 Wed 23:49]

Main use of "data" is to print out what is currently stored.  So maybe just have a built-in, "show-registers" say, that does this.

up's main use is to execute a statement inline.  Rather than executing

set :cur [ add :cur 1 . ] .

before, could do,

set :n ( set :cur [ add :cur 1 . ] \up . ) .

Now, let's just use a syntax for executing inline.

n ,
i ,


basically, we want macros.  We want to use macros.

set :n < set :cur [ add :cur 1 . ] . > .

To start, these should be textual macros.

Like ,

set :concat_all < collapse #1 concat #2 . > .
concat_all \strlst "#" .
expands to 
	collapse \strlst concat "#" .

as if it was typed exactly like that.

Decided on just using a built-in "up" instruction
* DONE Make `up` more efficient.  Currently it is copying its arguments twice.
  CLOSED: [2019-12-02 Mon 00:15]
* TODO Have an "assert"-like command which checks type of values at registers and errors if register does not exist or if the type doesn't match
* TODO do-to-all should have a prefix option like similar instructions, order of registry and instruction should be same
* DONE Registries should really be hash tables to improve lookup speed
  CLOSED: [2019-12-02 Mon 00:15]

Idea is to make "registry" be a hash table containing what is now "registry".

Something like:

struct registry
{
	registry_content* contents[HASH_SIZE];
  struct registry* up;
};

struct registry_content = old struct registry

One idea is to use current "perfect hash" mod HASH_SIZE

"contents" will be set to current "head" registry.
* DONE Need to start hash tables with NULL, or maybe have a list of nodes with data already included in registry to make get faster...
  CLOSED: [2019-12-02 Mon 00:15]
* TODO Make fundamental objects be vectors, so there is a dimension element to them.

Idea would be to use "_" for element so:

x_1 = first element of x
x_2 = second element, etc


words-are-separated-with-dashes

* TODO op_last should error if no value found with prefix or return an error code (i.e. a register like /0 which could not normally be used).  Currently returns prefix0.

* DONE Not a huge fan of the Lisp/Scheme like naming convention I have now for the objects.  Just visually with the kind of punctuation I am using.  Will experiment.
  CLOSED: [2019-12-01 Sun 18:39]

I actually don't think there is much better.  Tried a few things.  Like current convention best.

* DONE Make registries true hash table (i.e. number of bins grows with entries)
  CLOSED: [2019-12-19 Thu 18:43]

* TODO Consider name change to something hash based.  Maybe switch from "registry" terminology?  Although I kind of like that.

* DONE Some way to "capture" errors so they do not stop interpretation
  CLOSED: [2019-12-02 Mon 15:19]

* TODO Make sure to add a way to change error stop threshold.

* DONE There is something that creates a registry without using new_registry and it does not set size
  CLOSED: [2019-12-02 Mon 11:35]



* DONE Allow do-to-all to take multiple registries, removing join
  CLOSED: [2019-12-19 Thu 18:43]

* TODO Better error checking (backtrace)
- [X] Have the statement where an error occurred printed.
- [ ] Backtrace towards exactly where it was called from

* DONE Ability to interrupt a command
  CLOSED: [2019-12-19 Thu 23:00]

Maybe just a check at start of all operations for whether an error?  That way it can't exit mid-operation.  There shouldn't be any operations that take significant time before executing an operation anyway.

* TODO Parallel

I think we could simply launch a thread in another registry and set the /ans Register to that registry.  Something like this:

fork INSTRUCTION .
move /ans /thread1 .
wait thread1 .

Data type of data at /thread1 is just a Registry.  But we will add some locking flags to Registries so that they can be locked.

Without a thread, wait waits until current registry can be modified again.

wait .

waits until current thread can be modified.

* DONE Registries aren't treated fully as pass by reference somehow...
  CLOSED: [2019-12-25 Wed 00:54]

Code to replicate:

set /d [ registry . ] .
set /my-set ( in data ( set loc val . ) . ) .
my-set /data d /loc /x /val 5 .


I was wrong about how arguments were being passed.  Really was by
value for Instructions instead of by reference as for Operations.  All
should be passed by reference otherwise a little weird.

Fixed.  Now all are pass by reference.

