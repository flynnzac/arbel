* CANCELLED Add ability to switch output from screen to also write to file
  CLOSED: [2019-08-21 Wed 18:11]

  - State "CANCELLED"  from "TODO"       [2019-08-21 Wed 18:11] \\
    Don't think this is as useful as I though, should just have a logging function
* DONE File input / a File datatype
  CLOSED: [2019-08-15 Thu 12:08]

* DONE More convenient file input (currently just have the bare minimum to make it work: read character-by-character.)
  CLOSED: [2019-08-17 Sat 17:11]
** DONE Add read-line
   CLOSED: [2019-08-16 Fri 14:48]
** TODO Add write/write-line
** TODO Add Perl-ish "slurp"
* DONE Documentation: Better explanation of how substatements work in the docs/how the system uses the ans register.
  CLOSED: [2019-08-21 Wed 18:11]
* DONE OR/AND/NOT
  CLOSED: [2019-08-15 Thu 12:08]
* DONE Any error should stop whole instruction
  CLOSED: [2019-08-16 Fri 14:48]
* DONE Segfault when trying to go-in a nonexistent ref
  CLOSED: [2019-08-16 Fri 14:48]
* DONE Someway to easily move data from one environment to another.
  CLOSED: [2019-08-17 Sat 17:11]

Probably something like

in \reg1 ( set $buffer [ get $#key1 \my-data . ] . ) $my-data \reg2 .

It's probably easier to just have

set REGISTER VALUE REGISTRY .
as an option

* DONE Consider whether want [ instruction ] to run in new registry (I think so)
  CLOSED: [2019-08-21 Wed 17:49]

Implemented

* CANCELLED Have a for loop.  It's basically just some sugar for the while statement, but do it because very common.
  CLOSED: [2019-09-11 Wed 08:18]



  - State "CANCELLED"  from "TODO"       [2019-09-11 Wed 08:18] \\
    Purpose accomplished by the repeat instruction
Idea would be:

for REGISTER VALUE INSTRUCTION1 INSTRUCTION2 INSTRUCTION3

Where: 

REGISTER is the register that is being iterated
VALUE is the initial value of the register
INSTRUCTION1 is the instruction to execute that sets the ans register to the next value.  
INSTRUCTION2 is the instruction to execute to see if we should continue (set ans to 1 if yes, 0 if no)
INSTRUCTION3 is the body of the loop

So:

for $i $#1 ( next \i . ) ( exist-in \i \reg . ) ( print \i . ) .





* DONE Add a way to call shell
  CLOSED: [2019-08-21 Wed 18:11]

Some instruction like "shell"

shell STRING .

Executes a command

returns any output as string.

* DONE Add a way to accept user input interactively
  CLOSED: [2019-08-18 Sun 12:39]

Thinking 

input $register .

Takes input and assigns it to register.

* TODO A parse function that turns a string into a parsed object

This can basically be satisfied by having a "parse object" function in parse.c

Want to have a generic:

parse "'Hello'" . => "Hello"

parse "1" . => 2




* DONE Handle () code better
  CLOSED: [2019-08-24 Sat 02:53]

( CODE ) should not just be re-interpreted repeatedly

It seems like the obvious series of things to execute is:

INSTRUCTION ARG1 ARG2 ... ARGN .

Becomes:

new registry. ans =
#0 = INSTRUCTION 
#1 = ARG1
#2 = ARG2
...
#N = ARGN
up = current-context

Then call compute on that registry.

So we should have a function that does this from a statement.

set $addone ( add #1 1 . print ans . )

Should have the following pass:

addone = Array of Statements

Statement 1: 
add
lookup(#1)
literal(1)

Statement 2:
print
lookup(ans)

Then when: addone 2 .

Create registry:
Set: #0 addone
Set: #1 2
Execute Statement 1 in this registry.
Execute Statement 2 in this registry.



If we had used references


** DONE 1: malloc_consolidate(): invalid chunk
   CLOSED: [2019-08-22 Thu 23:12]

source "factorial.arb" .
factorial 5 .
factorial 4 .

** DONE 2: while needs to be re-instated
   CLOSED: [2019-08-23 Fri 01:27]

** DONE 3: Need to be able to enter multi-line code on prompt again
   CLOSED: [2019-08-23 Fri 01:27]

** DONE 4: Memory-management for instructions and statement structures
   CLOSED: [2019-08-23 Fri 01:27]

** DONE 5: Execute each statement in its own registry
   CLOSED: [2019-08-23 Fri 18:33]

** DONE 6: "ans" register doesn't get looked up in integral.arb (works if you store ans somewhere else)
   CLOSED: [2019-08-24 Sat 02:44]

** DONE 7: get save/load working again
   CLOSED: [2019-08-24 Sat 02:52]


* DONE Clean up error-handling with new parsing strategy
  CLOSED: [2019-08-25 Sun 02:46]

* DONE Add more basic math functions (log, exp, to-power)
  CLOSED: [2019-09-11 Wed 08:17]

* DONE Reduce unnecessary copying (thinking first for literals because that is mostly a change in basic memory management) 
  CLOSED: [2019-09-11 Wed 08:17]

* DONE Add c for new comment notation to doc
  CLOSED: [2019-08-27 Tue 23:51]
* TODO An operation that does nothing but "lookup" all arguments.  To evaluate active instructions. `sit` is a good candidate
* DONE Add regular expression function
  CLOSED: [2019-08-30 Fri 16:52]
`match` should give a registry of registries with each subregistry containing a different match.  Currently, it is just matching once.

Should add a substitute method.

Something like:

replace-one REGEX STRING . (replace first occurence in string)

* DONE Issue with parenthesis in quote expressions with parser
  CLOSED: [2019-08-28 Wed 13:23]


* DONE Add equivalent versions of assign which do not allocate but simply assume the memory has been allocated.  Will make many basic ops more efficient
  CLOSED: [2019-09-11 Wed 08:19]
* DONE Split out escaping strings from assigning strings.  Just an argument to copy.
  CLOSED: [2019-08-30 Fri 16:52]
* DONE Should be able to pre-allocate and hash names for registries of statements.  There are a fixed number of arguments, no reason it couldn't be done ahead of time.  Would make functions/loops faster.
  CLOSED: [2019-09-01 Sun 15:34]
* DONE Performance improvements
  CLOSED: [2019-09-02 Mon 21:59]
** DONE Registers/References can be hashed at allocation and copied without calling hash_str again
   CLOSED: [2019-09-02 Mon 02:09]
** DONE Hash element names before calling statements
   CLOSED: [2019-09-02 Mon 03:39]
** DONE Instructions at #0 should not be copied to new registry
   CLOSED: [2019-09-02 Mon 03:39]
** DONE If register already exists, do not delete it.  Just replace its data.
   CLOSED: [2019-09-02 Mon 03:39]
** TODO do-to-all, join, collapse all look really inefficient compared to what they could be
* DONE After performance improvements, looks like some difficulty retrieving references to \#1 etc throughout an instruction.
  CLOSED: [2019-09-02 Mon 21:59]
* DONE Comment settled as *, switch from ! because might be useful for "modification syntax"
  CLOSED: [2019-09-02 Mon 22:00]
* DONE Switched to ' for comment because might want to use * for some sort of globbing thing.  
  CLOSED: [2019-09-02 Mon 22:16]

* DONE Create a convenient syntax for accessing registers in registries
  CLOSED: [2019-09-03 Tue 16:32]

Current idea is the syntax: 

REGISTRY/REGISTER

If register is a REGISTRY itself, then

REGISTRY/REGISTER/REGISTER 

should work

Settled on

REGISTRY:REGISTER

for aesthetic reasons


* DONE Write the access notation for registries so that it is more "programmatic".
  CLOSED: [2019-09-03 Tue 21:59]

i.e. expect registers as values.  Some will be literal registers and others will not lookup values that (presumably) return registers.  We should keep this part "syntax" rather than language so don't allow substatemets or anything crazy but:

set @i @#1 .
add A:i 1 .


* DONE I actually like / so keep it
  CLOSED: [2019-09-03 Tue 21:59]

* DONE Make references work with slash notation
  CLOSED: [2019-09-04 Wed 17:57]
* DONE Decision not to make registers "work" with slash notation
  CLOSED: [2019-09-04 Wed 17:57]

I considered beig able to reference registers in the following way,

set @A/@#1/@#2 5 .

Instead, I decided to keep it like this:

set @#2 5 \A/@#1 .

Much simpler to understand (a register literal has no inherent context).
* DONE Document slash notation
  CLOSED: [2019-09-10 Tue 23:58]
** DONE Important to note how this allows for "namespaces"
   CLOSED: [2019-09-10 Tue 23:59]

Like so,

set @namespace [ reg . ] .
set @func1 ( ... ) \namespace .
* DONE Decide whether to use #1 or _1 or similar
  CLOSED: [2019-09-04 Wed 23:35]
@#1 #1 - stick with this
@_1 _1
@:1 :1 
@1- 1-
@=1 =1
@$1 $1
@*1 *1
@,1 ,1
@~1 ~1
* DONE Really need to clean up do-to-all, join, collapse, next code.  It's bad.
  CLOSED: [2019-09-11 Wed 08:17]
* TODO Do another efficiency pass
* TODO An "of" and "isof" typing system?
* TODO Consider whether we want to reserve register type with post-sigils

Like so:

a string = :string$
a registry = :registry@
an integer = :integer#
a decimal - :decimal%
an instruction = :instruction
a file = :file_
a register = :register:
* DONE Remove data and up registers.  Think of a better way to get that feature.
  CLOSED: [2019-09-11 Wed 23:49]

Main use of "data" is to print out what is currently stored.  So maybe just have a built-in, "show-registers" say, that does this.

up's main use is to execute a statement inline.  Rather than executing

set :cur [ add :cur 1 . ] .

before, could do,

set :n ( set :cur [ add :cur 1 . ] \up . ) .

Now, let's just use a syntax for executing inline.

n ,
i ,


basically, we want macros.  We want to use macros.

set :n < set :cur [ add :cur 1 . ] . > .

To start, these should be textual macros.

Like ,

set :concat_all < collapse #1 concat #2 . > .
concat_all \strlst "#" .
expands to 
	collapse \strlst concat "#" .

as if it was typed exactly like that.

Decided on just using a built-in "up" instruction
* TODO Make `up` more efficient.  Currently it is copying its arguments twice.
* TODO Have an "assert"-like command which checks type of values at registers and errors if register does not exist or if the type doesn't match
* TODO do-to-all should have a prefix option like similar instructions, order of registry and instruction should be same

