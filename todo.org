* CANCELLED Add ability to switch output from screen to also write to file
  CLOSED: [2019-08-21 Wed 18:11]

  - State "CANCELLED"  from "TODO"       [2019-08-21 Wed 18:11] \\
    Don't think this is as useful as I though, should just have a logging function
* DONE File input / a File datatype
  CLOSED: [2019-08-15 Thu 12:08]

* DONE More convenient file input (currently just have the bare minimum to make it work: read character-by-character.)
  CLOSED: [2019-08-17 Sat 17:11]
** DONE Add read-line
   CLOSED: [2019-08-16 Fri 14:48]
** TODO Add write/write-line
** TODO Add Perl-ish "slurp"
* DONE Documentation: Better explanation of how substatements work in the docs/how the system uses the ans register.
  CLOSED: [2019-08-21 Wed 18:11]
* DONE OR/AND/NOT
  CLOSED: [2019-08-15 Thu 12:08]
* DONE Any error should stop whole instruction
  CLOSED: [2019-08-16 Fri 14:48]
* DONE Segfault when trying to go-in a nonexistent ref
  CLOSED: [2019-08-16 Fri 14:48]
* DONE Someway to easily move data from one environment to another.
  CLOSED: [2019-08-17 Sat 17:11]

Probably something like

in \reg1 ( set $buffer [ get $#key1 \my-data . ] . ) $my-data \reg2 .

It's probably easier to just have

set REGISTER VALUE REGISTRY .
as an option

* DONE Consider whether want [ instruction ] to run in new registry (I think so)
  CLOSED: [2019-08-21 Wed 17:49]

Implemented

* TODO Have a for loop.  It's basically just some sugar for the while statement, but do it because very common.

Idea would be:

for REGISTER VALUE INSTRUCTION1 INSTRUCTION2 INSTRUCTION3

Where: 

REGISTER is the register that is being iterated
VALUE is the initial value of the register
INSTRUCTION1 is the instruction to execute that sets the ans register to the next value.  
INSTRUCTION2 is the instruction to execute to see if we should continue (set ans to 1 if yes, 0 if no)
INSTRUCTION3 is the body of the loop

So:

for $i $#1 ( next \i . ) ( exist-in \i \reg . ) ( print \i . ) .





* DONE Add a way to call shell
  CLOSED: [2019-08-21 Wed 18:11]

Some instruction like "shell"

shell STRING .

Executes a command

returns any output as string.

* DONE Add a way to accept user input interactively
  CLOSED: [2019-08-18 Sun 12:39]

Thinking 

input $register .

Takes input and assigns it to register.

* TODO A parse function that turns a string into a parsed object

This can basically be satisfied by having a "parse object" function in parse.c

Want to have a generic:

parse "'Hello'" . => "Hello"

parse "1" . => 2




* DONE Handle () code better
  CLOSED: [2019-08-24 Sat 02:53]

( CODE ) should not just be re-interpreted repeatedly

It seems like the obvious series of things to execute is:

INSTRUCTION ARG1 ARG2 ... ARGN .

Becomes:

new registry. ans =
#0 = INSTRUCTION 
#1 = ARG1
#2 = ARG2
...
#N = ARGN
up = current-context

Then call compute on that registry.

So we should have a function that does this from a statement.

set $addone ( add #1 1 . print ans . )

Should have the following pass:

addone = Array of Statements

Statement 1: 
add
lookup(#1)
literal(1)

Statement 2:
print
lookup(ans)

Then when: addone 2 .

Create registry:
Set: #0 addone
Set: #1 2
Execute Statement 1 in this registry.
Execute Statement 2 in this registry.



If we had used references


** DONE 1: malloc_consolidate(): invalid chunk
   CLOSED: [2019-08-22 Thu 23:12]

source "factorial.arb" .
factorial 5 .
factorial 4 .

** DONE 2: while needs to be re-instated
   CLOSED: [2019-08-23 Fri 01:27]

** DONE 3: Need to be able to enter multi-line code on prompt again
   CLOSED: [2019-08-23 Fri 01:27]

** DONE 4: Memory-management for instructions and statement structures
   CLOSED: [2019-08-23 Fri 01:27]

** DONE 5: Execute each statement in its own registry
   CLOSED: [2019-08-23 Fri 18:33]

** DONE 6: "ans" register doesn't get looked up in integral.arb (works if you store ans somewhere else)
   CLOSED: [2019-08-24 Sat 02:44]

** DONE 7: get save/load working again
   CLOSED: [2019-08-24 Sat 02:52]


* DONE Clean up error-handling with new parsing strategy
  CLOSED: [2019-08-25 Sun 02:46]

* TODO Add more basic math functions (log, exp, to-power)

* TODO Reduce unnecessary copying (thinking first for literals because that is mostly a change in basic memory management) 

* DONE Add c for new comment notation to doc
  CLOSED: [2019-08-27 Tue 23:51]
* TODO An operation that does nothing but "lookup" all arguments.  To evaluate active instructions. `sit` is a good candidate
* DONE Add regular expression function
  CLOSED: [2019-08-30 Fri 16:52]
`match` should give a registry of registries with each subregistry containing a different match.  Currently, it is just matching once.

Should add a substitute method.

Something like:

replace-one REGEX STRING . (replace first occurence in string)

* DONE Issue with parenthesis in quote expressions with parser
  CLOSED: [2019-08-28 Wed 13:23]


* TODO Add equivalent versions of assign which do not but simply assume the memory has been allocated.  Will make many basic ops more efficient
* DONE Split out escaping strings from assigning strings.  Just an argument to copy.
  CLOSED: [2019-08-30 Fri 16:52]
* DONE Should be able to pre-allocate and hash names for registries of statements.  There are a fixed number of arguments, no reason it couldn't be done ahead of time.  Would make functions/loops faster.
  CLOSED: [2019-09-01 Sun 15:34]
* TODO Performance improvements
** TODO Registers/References can be hashed at allocation and copied without calling hash_str again
** 
