# -*- org-html-preamble-format: (("en" "%t<br>%a<br>%T")); -*-
#+TITLE: ARBEL
#+AUTHOR: Zach Flynn
#+DESCRIPTION: ARBEL is a registry-based environment and language. 

* Code inside Data

ARBEL code is executed inside a data set called a registry.  Registries are tables with values entered in /registers/. The programmer enters commands to modify the contents of the registry and possibly send the results of any computations performed on the data to another registry.

Code in ARBEL has no context or scope of its own.  It requires a registry to give it context.  For example,
#+BEGIN_SRC arbel
... print x .
#+END_SRC

requires that the registry contains data located at the =print= and =x= register.  Different registries could contain different values at these locations so the same code might perform different actions in different contexts.  

* Syntax

ARBEL code consists of a number of statements.  Each statement contains a series of data values, either literals or values located in the current registry, separated by whitespace and ending with a period.  All elements of a statement must be separated by whitespace from the preceding element, including the terminating period.
#+BEGIN_SRC arbel
... data1 data2 data3 data4 .
#+END_SRC

The following are examples of statements:
#+BEGIN_SRC arbel
... add 1 2 .
ans = 3
... print "Hello" .
Hello
#+END_SRC

The first element of a statement is an operation that performs some transformation of the other data elements in the statement and the contents of the registry in which the statement is executed.  The first statement uses the operation located at the =add= register.  The second uses the operation located at the =add= register.  The numbers and the the string ="Hello"= are literals.

** Literals and Names

Names are sequences of characters that are not literals and not parenthesis (=()=, =[]=, ={}=, =<>=).  A name appearing in a statement indicates the value located at the register with that name.

Literals represent a value of data.

*** Numeric Literals
Numbers are a sequence of digits either with or without a decimal point.  With a decimal point, the type of the literal is a Real.  Without a decimal point, the type of the literal is an Integer. Example: =123= and =1.23=.

*** String Literals
Strings are a sequence of characters enclosed by double quotes (=""=). Example: ="Hello, world."=.  

*** Boolean Literals
Boolean literals are one of two words: =True= and =False= (case sensitive).  

*** Register Literals
A register location is a name preceeded by a forward slash =/=.  Example: =/hello=, =/x1=.  These literals refer to the register location, not its value.  Almost any string of characters is a valid register location, but some will be less convenient to access because they collide with other elements of ARBEL's syntax.  But they can still be used.  For example,
#+BEGIN_SRC arbel
... set /. 1 .
... get /. .
ans = 1
#+END_SRC

Can be used to access the value when the register's value cannot be accessed in the usual way, by omitting the forward slash.

*** Instruction Literals
Instructions are ARBEL statements enclosed in open parenthesis.  Instructions are code that is not executed but saved as data to be used in another environment.  Example: =( add t 2 . mul ans 5 . )= which is an instruction to add =2= to the value at a register =/t= and multiply the answer by =5=. This code is not executed and resolves to a type of data called an Instruction.  It is treated as a literal value.  The whitespace following the first parenthesis and preceeding the last is required.

*** Operator Literals
Operations are like instructions except that they are less flexible because they must be called in a certain way with fixed positional arguments.  Operation literals are enclosed in angle brackets (=<>=) like so: =< ( add t 1 . ) /t >=.  The first element inside the angle brackets is an instruction.  The rest of the arguments are registers which give the data locations to bind the operator's arguments to when called so that: =< ( add t 1 . ) /t > 10 .= would give =11=.  These values are treated as literals of the Operation type.

*** The Nothing Literal

The word =Nothing= is a literal value of type =Nothing=.  =Nothing= is not like other data types.  That is the most important thing about it.  It can be used as the return value for errors and other situations.

** Substatements 

ARBEL statements can contain two forms of substatements in place of a data element.  The substatements differ by when the code they contain is executed.  

*** Immediate Substatements

 Immediate substatements are executed as soon as they are encountered.  They evaluate to the value of the =ans= register in the registry where the code is executed after the substatement is executed. They are enclosed in square brackets.

 #+BEGIN_SRC arbel
 ... add [ sub 5 3 . ] 10 .
 ans = 12
 #+END_SRC

 =sub= is the usual location of the subtraction operator.  The bracketed substatement is evaluated and replaced with the value of the =ans= register after =sub 5 3 .= is executed.   The subtraction and other arithmetic operations set the =ans= register to their result.  So =2= is the first data element in the outer statement.  =add= then adds =2= and =10= setting the =ans= register to =12=.

*** Active Instructions

 Active instructions are executed /when they are used/.  They are usually used in conditional operations so that code is not executed unless it is required.  They are enclosed in curly braces.
 #+BEGIN_SRC arbel
 ... if True { print "hello" . } { print "goodbye" . } .
 hello
 ... if False { print "hello" . } { print "goodbye" . } .
 goodbye
 ... if True [ print "hello" . ] [ print "goodbye" . ]
 hello
 goodbye
 #+END_SRC

 This code block illustrates the difference between active instructions and immediate substatements.  The =if= operation accesses and returns its second argument if the first argument is =True= and the third argument if the first is =False=.  So, only the first active instruction is executed in the first line of code and only the second active instruction is executed in the second line.  The third line uses immediate substatements instead.  These are executed as soon as they are encountered regardless of whether the =if= operation accesses their value.

* Overview of ARBEL vocabulary

ARBEL statements consist of sequences of data.  Statements start with an operation, generally, and other types of data follow.  ARBEL the language consists of operations that implement each data type.  Users of ARBEL do not specify new types unlike in many languages.  ARBEL uses a single flexible data structure, the registry, to describe many types.  Like lists in Lisp.

* Registries

** Registries as data structures
Registries are tables of data located at registers.  Register locations are prefixed with a forward slash in ARBEL so:
#+BEGIN_SRC arbel
/hello
/x
/z123
#+END_SRC

are all examples of register locations in ARBEL.  The value located at a registry is referenced by removing the forward slash.
#+BEGIN_SRC arbel
... set /x 10 .
... print x .
10
#+END_SRC

The =set= operation assigns a value to a register. Values can also be retrieved from registries using the =get= operation:
#+BEGIN_SRC arbel
... set /x 10 .
... get /x .
ans = 10
#+END_SRC

The =move= operation moves values between registers without copying the underlying data.
#+BEGIN_SRC arbel
... set /x 10 .
... print x .
10
... move /x /y .
... print x .
Error: Value at register /x not found.
... print y .
10
#+END_SRC

The =delete= operation deletes a value from a given register in the current registry.
#+BEGIN_SRC arbel
... set /x 10 .
... print x .
10
... delete /x .
... print x .
Error: Value not found at /x register.
#+END_SRC 

The =registry= operation creates a new registry.
#+BEGIN_SRC arbel
... registry /x 10 .
ans = a registry with:
x of type Integer, value: 10
#+END_SRC

The =registry= operation takes a series of register value pairs as input and creates a registry with each value stored at each register.  After a new registry is created, values can be set and retrieved from the registry using the =set= and =get= operation's optional final argument.
#+BEGIN_SRC arbel
... set /r [ registry /x 10 . ] .
... get /x r .
ans = 10
... set /y 4 r .
... get /y r .
ans = 4
#+END_SRC

Values in other registries can also be accessed by using the colon syntax.  The value located at a certain register in another registry can be written as:
#+BEGIN_SRC arbel
registry:register
#+END_SRC

For example,
#+BEGIN_SRC arbel
... set /r [ registry /x 10 . ] .
... print r:/x .
10
... set /y /x .
... print r:y .
10
#+END_SRC

This notation can be nested.  So a value in a registry located at a register inside another registry can be accessed with:
#+BEGIN_SRC arbel
registry:register:register
#+END_SRC

Where the first register is the location of another registry inside the registry.  Like so,
#+BEGIN_SRC arbel
... set /r [ registry /s [ registry /x 10 . ] . ] .
... print r:/s:/x .
10
#+END_SRC

Elements of a registry can be selected using the =find= operation.  The find operation takes a registry and an operation as arguments.  The operation should take two arguments.  The first is a value in the registry.  The second is the register the value is located at in the registry.  If the element should be selected, the operation should set the =/ans= register to =True=.  If it should not be, the operation should set the =/ans= register to =False=.

#+BEGIN_SRC arbel
... set /r [ list 4 2 3 "hello" . ] .
... print r .
ans = a registry with:
t1 of type Integer, value: 4
t2 of type Integer, value: 2
t3 of type Integer, value: 3
t4 of type String, value: "hello"
... find r < ( is-integer value . ) /value /key > .
ans = a registry with:
t1 of type Integer, value: 4
t2 of type Integer, value: 2
t3 of type Integer, value: 3
#+END_SRC

The =import= operation is used to take the objects from one registry and add them to another. 
#+BEGIN_SRC arbel
... set /r [ registry /x 10 . ] .
... print x .
Error: Value not found at register /x.
... import r .
... print x .
10
#+END_SRC

=exist= checks whether a value is located in a registry.  It sets the =/ans= register to =True= if it is and to =False= if it does not.
#+BEGIN_SRC arbel
... set /x 10 .
... exist /x .
ans = True
... delete /x .
... exist /x .
ans = False
... set /r [ registry /z 50 . ] .
... exist /z r .
ans = True
... exist /z .
ans = False 
#+END_SRC

** Registries as environments

Registries are both a data structure as described above, and an environment in which code is executed.  To change which registry code is being executed in, use the =go-in= operation to change the current registry to another registry.  Use the =go-out= operation to move up to the previous registry.
#+BEGIN_SRC arbel
... /set /r [ registry . ] .
... go-in r .
... set /x 10 .
... print x .
10
... go-out .
... print x .
Error: Value not found at /x register.
... print r:/x .
10
#+END_SRC


An instruction can also be executed in a registry using the =in= operation.
#+BEGIN_SRC arbel
... set /r [ registry /t 1 . ] .
... print r:/t .
1
... in r ( move /t /s . ) .
... print r:/s .
1
... print s .
Error: No value found at register /s.
#+END_SRC

* Registers

Registers are a full-fledged data type.  Register locations can be inserted into a registry.
#+BEGIN_SRC arbel
... set /x /y .
... set x 10 .
... print x .
/y
... print y .
10
#+END_SRC

Registries with an array-like structure often have registers with names like: =/r1,/r2,/r3=.  ARBEL has convenience operations to work with registers like these.

=list= creates registries where each element is at register location =/t1,/t2,/t3,...=.  
#+BEGIN_SRC arbel
... list 1 2 3 .
ans = a registry with:
t1 of type Integer, value: 1
t2 of type Integer, value: 2
t3 of type Integer, value: 3
#+END_SRC

=next= and =previous= set the =/ans= register to the next or previous register for registers that end in numeric values.
#+BEGIN_SRC arbel
... next /element10 .
ans = /element11
... previous /element10 .
ans = /element9
#+END_SRC



* Instructions

Instructions are code literals.  In syntax, they are statements enclosed in open parenthesis. Instructions can be executed with either the =in= or the =call= operations and they are often used as arguments for various operations like loops.  

** In operation

The =in= operation executes the instruction inside an existing registry.

#+BEGIN_SRC arbel
... set /assign-x ( set /x 10 . ) .
... set /y [ registry . ] .
... in y assign-x .
... print x .
Error: Value at register /x not found.
... in _ assign-x .
... print x .
10
#+END_SRC

This example demonstrates both using instructions and how ARBEL code executes inside registries.  The =registry= operation creates a new registry.  The statement =in y assign-x= executes the code in the instruction located at =/assign-x= in the context of the =y= register.  So, within the =y= registry, the value located at =/x= is =10=.  But, because we are currently not inside the =/y= registry, after the =in= command we cannot access those registries so =print x= prints nothing.  The special name =_= refers to the current registry.  So =in _ assign-x= runs the instruction =assign-x= in the current registry.  So =/x= in the current registry now holds the value =10=.

** Call operation

The =call= operation executes the instruction inside a temporary registry defined by the user calling the code.  It then sets the =/ans= register in the calling registry to the value of the =/ans= register in the temporary registry.
#+BEGIN_SRC arbel
... set /add-one ( add t 1 . ) .
... call add-one /t 10 .
ans = 11
#+END_SRC

The =call= operations takes an instruction and then alternating register value pairs as arguments.  The register value pairs define the state of the temporary registry when the code is run.  Because the caller of the code defines the state of the registry, any non-literal can be modified by the caller.
#+BEGIN_SRC arbel
... set /add-one ( add t 1 . ) .
... call add-one /t 10 .
ans = 11
... call add-one /t 10 /add sub .
ans = 9
#+END_SRC

The second line typically located at the register =/add= (the =add= operation) with the operation located at the register =/sub= (the =sub= operation).  But it only makes this replacement in the temporary registry.  The registry calling the code is unaffected by this change.  So =call add-one /t 10 /add sub= subtracts =1= from =10= instead of adds.

The main difference between the =in= and =call= operation is that the =call= operation moves the value of =/ans= in the temporary registry it creates back to the calling registry.  The =in= operation is typically used for modifying registries and the =call= operation is typically used for computations.

As a convenience, if an instruction is the first data object in a statement, ARBEL assumes that you want to =call= it.  It operates exactly the same as if you had included the =call= operation itself.
#+BEGIN_SRC arbel
... set /add-one ( add t 1 . ) .
... add-one /t 10
ans = 10
#+END_SRC

=answer= is a useful operation when calling instructions.  =answer= sets the =/ans= register to whatever argument is provided to the operation.  It highlights that the data is being returned to the registry that called the operation, but =answer DATA= is functionally equivalent to =set /ans DATA=.

** The collapse and do operations

The =collapse= and =do= operations iterate over the elements of a registry and create a new registry.  

The =collapse= operation aggregates over data at a number of registries.  Collapse makes use of a special structure put on the registry where some registers have the form =/prefixNNN...N=  where =NNN...N= is a natural number.  The =list= operation creates a registry with this form where the prefix is =t=.
#+BEGIN_SRC arbel
... set /r [ list 1 2 3 . ] .
... print r .
ans = a registry with:
t1 of type Integer, value: 1
t2 of type Integer, value: 2
t3 of type Integer, value: 3
... collapse add r /t .
ans = 6
#+END_SRC

The =collapse= operation takes an operation that takes (at least) two arguments as its first argument.  Elements of the registry provided in the second argument that match the prefix provided in the third argument are fed in sequentially to the operation.  The collapse operation does the equivalent of:
#+BEGIN_SRC arbel
... add r:/t1 r:/t2 .
ans = 3
... add ans r:/t3 .
ans = 6
#+END_SRC

The =do= operation applies another operation to all elements in a registry.

** Defining operations

Most new procedures that a programmer writes in ARBEL are instructions, but it is sometimes useful to have "positional" arguments like operations.  Users write operations by writing instructions and assigning argument numbers to different registers in the temporary registry. They can be defined using angle brackets or the =op= operation.

#+BEGIN_SRC arbel
... set /add-one [ op ( add t 1 . ) /t . ] .
... add-one 5 .
ans = 6
... set /add-one < ( add t 1 . ) /t > .
... add-one 5 .
ans = 6
#+END_SRC

* Booleans and Control Flow

The primary "control flow" operations in ARBEL are =if= and =while=.  Control flow in ARBEL is achieved with operations that execute code repeatedly or conditionally.

** The if operation

=if= takes three arguments.  If its first argument is =True=, it sets the =/ans= register to the second argument.  If the third argument is =False=, it sets the =/ans= register to the third argument.
#+BEGIN_SRC arbel
... set /gt-3 < ( gt t 3 . ) /t > .
... set /max-3 < ( if [ gt-3 t . ] 3 t . ) /t > .
... max-3 4 .
ans = 3
... max-3 2 .
ans = 2
#+END_SRC

Frequently, we would like to execute some code if a condition is =True= and another piece of code if a condition is =False=.  To do this using the =if= operation, ARBEL uses active instructions.  Because active instructions are only executed if the code attempts to use the value, the statements will not be evaluated unless the =if= operation attempts to access its second or third argument.  Continuing from the above block of code,

#+BEGIN_SRC arbel
... if [ gt-3 4 . ] { print "Greater than 3." . } { print "Less than or equal to 3." . } .
Greater than 3.
... if [ gt-3 2 . ] { print "Greater than 3." . } { print "Less than or equal to 3." . } .
Less than or equal to 3.
... if [ gt-3 3 . ] { print "Greater than 3." . } { print "Less than or equal to 3." . } .
Less than or equal to 3.
#+END_SRC

** The while operation

=while= is the other main control flow operation in ARBEL.  =while= takes two instructions as arguments.  The first instruction is executed first in the current registry.  If the instruction sets the =/ans= register to =True=, the second instruction is executed in the current registry as well.  Then, the first instruction is executed again.  If it is =True=, the second instruction is executed again, and so on.

#+BEGIN_SRC arbel
... set /i 1 .
... while ( lt i 10 . )
          ( 
            print i . 
            set /i [ add i 1 . ] .
          ) .
1
2
3
4
5
6
7
8
9
#+END_SRC

** Logical concatenation

ARBEL also includes logical operations: =and=, =or=, and =not=.  

=and= and =or= take any number of Boolean arguments.  =and= sets the =/ans= register to =True= if all arguments are =True= and to =False= otherwise.  =or= sets the =/ans= register to =True= if any arguments are =True= and to =False= otherwise.  Both operations short circuit as soon as the result is clear.  This is only relevant if active expressions are used with =and= or =or=.  Because this is the only way that accessing the values has an effect on the program.  This behavior is useful for checking whether some condition is true before executing a command.

#+BEGIN_SRC arbel
... set /f ( or [ is-integer x . ] 
           { set /x [ add x 1 . ] . answer True . ] . } . 
             answer x . 
           ) .
... f /x 3.4 .
ans = 3.4
... f /x 10 .
ans = 11
#+END_SRC

* Numbers

ARBEL has two kinds of numeric data.  It has Real numbers (numbers with a decimal point) and Integer numbers (numbers without a decimal point). 

** Arithmetic
Real and Integer types are different in ARBEL, but the basic arithmetic operations do silently convert between the two.  Whenever both a Real and an Integer are used in arithmetic, the =/ans= register is a Real number.  The basic arithmetic operations are =add=, =sub=, =mul=, and =div=.  Dividing two integers gives an integer answer.  

#+BEGIN_SRC arbel
... add 1 2.0 .
ans = 3.0
... sub 4 1 .
ans = 3
... mul 2.5 2 .
ans = 5.0
... div 5 2 .
ans = 2
... div 5.0 2 .
ans = 2.5
#+END_SRC

The arithmetic operations can take any number of arguments so that three numbers could be summed by:

#+BEGIN_SRC arbel
... add 5 2 3 .
ans = 10
#+END_SRC

** Comparison

The numeric comparison operators are =gt= (greater than), =lt= (less than), =eq= (equal to), =lt-eq= (less than or equal to), and =gt-eq= (greater than or equal to).  These operations can also take any number of arguments.  These operations set the =/ans= register to =True= if the comparison is true and to =False= if it is false.

#+BEGIN_SRC arbel
... gt 4 3 .
ans = True 
... gt 10 2 3 4 5 .
ans = False
... gt 10 5 3 .
ans = True
#+END_SRC

** Exponentiation
The built in operations for exponentiation are =exp= to compute the natural exponent of a number, =log= to compute the natural logarithm of a number, and =power= to raise a number to a given power.

#+BEGIN_SRC arbel
... exp 1 .
ans = 2.718282
... log 2 .
ans = 0.693147
... power 2 0.5 .
ans = 1.414214
#+END_SRC

** Modulus

The modulus operation is =mod=.  It computes both the Integer and the Real modulus.

#+BEGIN_SRC arbel
... mod 5 2 .
ans = 1
... mod 5.0 2.6
ans = 2.4
#+END_SRC

** Increment and Decrement

For efficiency in loops, ARBEL includes operations to increment and decrement Integer values /in place/, without copying the value.
#+BEGIN_SRC arbel 
... set /x 5 .
... print x .
5
... incr x .
... print x .
6
... decr x .
... print x .
5
#+END_SRC

* Strings

Strings are ARBEL's data type for handling text data.  A literal string is text enclosed in double-quotes, like so: ="hello"=.  String literals can include the following escape sequences to input characters that would otherwise be difficult to insert.

| Escape Sequence  | Meaning          |
|------------------+------------------|
| \\               | \                |
| \'               | ' (single-quote) |
| \t               | tab              |
| \n               | newline          |
| \r               | carriage return  |
| ' (single-quote) | " (double quote) |
|------------------+------------------|

Strings are UTF-8 compliant so Unicode characters are valid characters and will be counted as single characters by string operations.  

** String manipulation

The =string-length= operation sets the =/ans= register to the number of characters in the string.

#+BEGIN_SRC arbel
... string-length "hello" .
ans = 5
... string-length "dÅµr" .
ans = 3
#+END_SRC

The =substring= operation sets the =/ans= register to a substring of =string= from characters =index1= to =index2=.  

#+BEGIN_SRC arbel
substring string index1 index2 .
#+END_SRC

ARBEL strings start at position =1=.  Indexes less than or equal to =0= have a special meaning.  They count backwards from the last character in the string.  So position =0= is the last character in the String.  There is no "character" type in ARBEL so =substring= is the primary way to access elements of strings.

#+BEGIN_SRC arbel
... substring "hello" -1 0 .
ans = "lo"
... substring "hello" 1 2 .
ans = "he"
... substring "hello" 3 3 .
ans = "l"
#+END_SRC

ARBEL provides the =string-append= operation to concatenate strings.  

#+BEGIN_SRC arbel
... string-append "hello " "world" .
ans = "hello world"
#+END_SRC

The =string-append= operation take an arbitrary number of arguments so, the following works as well.

#+BEGIN_SRC arbel
... string-append "hello" "world" "\nhi!" .
ans = "helloworld
hi!"
#+END_SRC

Using the =collapse= operation with =string-append= is a useful way to join a list of strings.

#+BEGIN_SRC arbel
... collapse string-append [ list "h" "e" "l" "l" "o" . ] /t .
ans = "hello"
#+END_SRC

** Regular expressions

ARBEL implements the POSIX regular expression language using the =match= and =replace= operations.  The =match= operation returns =matches= in a registry structure and =replace= sets the =/ans= register to the original string with all matches replaced with a given replacement string.

The syntax for the =match= operation is:

#+BEGIN_SRC arbel
... match regex string |max matches|
#+END_SRC

Where =|max matches|= is an optional argument denoting the maximum number of matches to return.  By default, it is =0= which indicates to return all matches.  If it is =2=, it would return the first two matches.  =match= sets the =/ans= registry to a registry that contains a registry for each match that divides the matched string into any groups specified in the regular expression.  For example,

#+BEGIN_SRC arbel
... match "el" "hello hello" .
ans = a registry with:
t1 of type Registry, value: a registry with:
t0 of type String, value: "el"
t2 of type Registry, value: a registry with:
t0 of type String, value: "el"
... match "(e)(l)" "hello hello" .
t1 of type Registry, value: a registry with:
t0 of type String, value: "el"
t1 of type String, value: "e"
t2 of type String, value: "l"
t2 of type Registry, value: a registry with:
t0 of type String, value: "el"
t1 of type String, value: "e"
t2 of type String, value: "l"
#+END_SRC

Each match contains the full match at =/t0= and then the subgroup matches at =/tGROUP=.

The =replace= operation is similar.  Its syntax is:

#+BEGIN_SRC arbel
... replace regex replacement original-string |max matches|
#+END_SRC

The optional =|max matches|= argument limits the number of replacements to make.  =replacement= is the string to replace all matches with.

#+BEGIN_SRC arbel
... replace "h" "e" "hello" .
ans = "eello" .
#+END_SRC

* Files

ARBEL provides a File type to manage writing and reading streams of data.  

The =open-file= operation... opens a file, setting the =/ans= register to the resulting file object.

#+BEGIN_SRC arbel
... open-file "myfile.txt" .
ans = A file
#+END_SRC

To read from the File, we can use the =read=, =read-char=, or =read-line= operations.  The =read= operation is primarily useful for reading binary data.  It reads a single byte from the file and sets the =/ans= register to the Integer value of the byte.  =read-char= and =read-line= are the primary operations for reading text files.  =read-char= reads a single character and sets the =/ans= register to a String result.  =read-line= reads a full line into a String.  Each of these operations modifies the state of the File.  The next read will grab the next character and so on.  When reading is complete, the read operations set the =/ans= register to =Nothing=

Suppose the file ="myfile.txt"= referenced above contained the following line only: =hello, world=

#+BEGIN_SRC arbel
... set /f [ open-file "myfile.txt" . ] .
... read f .
ans = 104
... read-char f .
ans = "e"
... read-line f .
ans = "llo, world"
#+END_SRC


Reading-by character works in Unicode as well.  Suppose =myfile.txt= contains only the word: =dŵr.=.

#+BEGIN_SRC arbel
... set /f [ open-file "myfile.txt" . ] .
... read-char f .
ans = "d"
... read-char f .
ans = "ŵ"
#+END_SRC

To close a file, ARBEL provides the =close= operation.  The =close= operation takes the register at which the File is located as its argument because ARBEL also needs to remove the File value from the register after closing the file.

#+BEGIN_SRC arbel
... set /f [ open-file "myfile.txt" . ] .
... close /f .
#+END_SRC

* Tasks (multi-threading)

ARBEL has facilities for multi-threaded code using a "task" system (vaguely) similar to the task system in Ada, but ARBEL-style.  ARBEL's tasks are a type of data.  You can do everything to them that you can do to other data (move it, delete it, etc).

Tasks are created with the =task= operation.  The =task= operation takes three arguments.  The first gives the register to assign the Task to.  The second gives the /body/ of the Task, an instruction that the Task will execute when it is run (Tasks do not immediately start running on creation).  The third argument is the initial state of the task, a registry defining the environment in which the task will run.

#+BEGIN_SRC arbel
... task /my-task ( commands to run... ) [ registry . ] .
#+END_SRC

Tasks are started with the =run-task= operation.  =run-task= takes a single argument, the task to start running.  Running a task means that the instruction that forms the body of the task is executed.

The key thing to understand about tasks is that their environment is entirely /separate/ from the current registry.  There is no way to directly access data in a task fro







* Interacting with the Shell
* Examples

** Short Examples

** Complete Program
