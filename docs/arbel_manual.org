# -*- org-html-preamble-format: (("en" "%t<br>%a<br>%T")); -*-
#+TITLE: ARBEL
#+AUTHOR: Zach Flynn
#+DESCRIPTION: ARBEL is a registry-based environment and language. 

* Data Types

ARBEL data is strongly-typed.  Each data value has a type and conversion between the types is explicito.  But the locations where data is stored --- called /registers/ in ARBEL --- have no type.  A location might store a number at one point in the program and then a string at another point.  

ARBEL values can have the following types:

- Integer
- Real
- String
- Boolean
- Register
- Registry
- Instruction
- Operation
- File
- Task
- Nothing

** Integers

Integers can be arbitrarily large in ARBEL without losing any precision.  They are whole numbers without a decimal point.  ARBEL interprets any sequence of numbers that does not include a decimal point as an Integer literal.  For example,
#+BEGIN_SRC arbel
3
#+END_SRC

is an Integer.

** Real

Reals are the floating point type in ARBEL.  Reals are always double-precision floats. ARBEL interprets any number with a decimal point as a Real.  Trailing zeros are always optional. For example,
#+BEGIN_SRC arbel
3.
1.5
#+END_SRC

are Reals.

** Strings

Strings are the data type for text in ARBEL.  Internally, they are UTF-8 encoded text strings.  Characters not in the ASCII character set are treated as single characters.  Literal strings are represented by surrounding text in double quotes, as in ="Hello, world!"=.

String literals also recognize the following escape sequences to introduce text that is either non-printing or difficult-to-enter.

| Escape Sequence  | Meaning          |
|------------------+------------------|
| \\               | \                |
| \'               | ' (single quote) |
| \t               | tab              |
| \n               | newline          |
| \r               | carriage return  |
| ' (single quote) | " (double quote) |
|------------------+------------------|


** Boolean

Booleans are commonly used in ARBEL as the result of a test or comparison.  There are only two Boolean literals: =True= and =False= (where the capitalization is significant). 

** Register

A register represents the /location/ of data instead of its value.  Registers are themselves full-fledged data types.  Register literals start with a forward-slash with any symbol following the slash giving the register's location. For example,
#+BEGIN_SRC arbel
/hello
/x1323
/-32st0x0 
#+END_SRC

are all valid Register literals.

** Registry

Registries are the only data structure in ARBEL.  They are tables with data (potentially including other registries) located at various registers.  Registries are both a data object and also used to determine the /scope/ of code.  Code is execute inside registries. Data locations referenced in the code refer to the data located at those registers in the registry in which the code is executed.

There is no literal representation of registries.  They are created by operations that will be detailed in later sections.

There are many operations to manipulate data in registries which form the core of ARBEL's programming environment.

** Instruction

Instructions are data that represents ARBEL code.  The code is saved as an object to be evaluated in a different environment or otherwise used as code to be evaluated (e.g. code to be executed repeatedly in a loop).

** Operation

An operation is a data object that performs some computation given a fixed set of arguments.  ARBEL provides several built-in operations that are used to create and manipulate the various types of data. 

New operations can also be created from instructions by specifying an environment known up to a finite set of parameters.

** File

The File type is primarily used for files on disk but it is a general "stream" type.  Data can be written to the stream and read from it.  Files have no literal representation.  They are created by operations.

** Task

Tasks are used for multi-process programs.  They are a full data-type, treated just like any other.  They contain a number of elements:

- a Body: code that the task will execute.
- a State: a registry that gives the environment for the Task.
- a Queue: an inaccessible registry that facilitates data-sharing between different tasks, including the main task.


* Basic Syntax

A simple ARBEL statement is a sequence of data objects, separated from each other by whitespace, ending in a period.  Every code element is separated from the other elements by whitespace, including the single period which terminates a statement.


* Basic Statements and the ARBEL environment

A statement is a sequence of data elements and sub-statements ending in a period.  Each code element must be separated from the others by whitespace, including the period which terminates the statement. For example:
#+BEGIN_SRC arbel
... print "Hello, world!" .
#+END_SRC

=print= is an operation and ="Hello, world!"= is a string.  ="Hello, world!"= is a /literal/, it represents a data value directly.  =print= is a /reference/ to the value stored at register =/print= in the registry where the code is executed.  ARBEL treats anything that is not a literal as a reference and attempts to look up the value.

Code is always executed "inside" a registry.  So registries are both a data type and determine the scope of code, what values are available to it.

* Language

This section describes the ARBEL language's form without reference to the environment or its particular operations.  It consists of a series of definitions.

A /Value/ is data.

A /Literal/ is a direct representation of a specific Value.  For example, the number =3=.

A /Reference/ is a symbol that represents the location of a Value.

A /Simple Statement/ is a sequence of Literals and References, written:
#+BEGIN_SRC arbel
X1 X2 X3 X4 ... XN .
#+END_SRC
Each element of the sequence is separated from the others by whitespace.  The period marks the end of the sequence.  It must also be separated from the elements of the sequence by whitespace.

An /Element/ is either a /Literal/, a /Reference/, or a /Substatement/.

A /Statement/ is a sequence of Elements.

An /Immediate Substatement/ is a sequence of Elements that can be included as one of the elements of an ARBEL Statement. The code represented by this sequence is executed prior to the rest of the Statement.  The statements are enclosed in square brackets (which are separated from the Statements by whitespace).  A Statement containing an immediate substatement looks like this:
#+BEGIN_SRC arbel
Element1 Element2 [ Statement1 . Statement2 . ... StatementN . ] Element3 ... ElementM .
#+END_SRC

A /Conditional Substatement/ is only computed if the outer Statement accesses the Substatement's Element.  The syntax is the same as for immediate substatements with the execption that the inner statements are enclosed in curly braces:
#+BEGIN_SRC arbel
Element1 Element2 { Statement1 . Statement2 . ... StatementN . } Element3 ... ElementM .
#+END_SRC

A /Substatement/ is either an Immediate Substatement or a Conditional Substatement.

An /Instruction/ is a type of data which contains a series of ARBEL statements to be executed later.  It is enclosed in open parenthesis:
#+BEGIN_SRC arbel
( Statement1 . Statement2 ... StatementN . )
#+END_SRC

An /Operation/ is a type of data that performs some action when it appears as the first Element of a Statement.  /Arguments/ refer to the rest of the Elements of a Statement. There are operations built into ARBEL, and they can be defined by the user using an angle bracket syntax which describes both the code to execute and the data locations (called /Registers/) at which to put the Elements before executing the code.  The following defines an operation:
#+BEGIN_SRC arbel
< Instruction Register1 Register2 ... RegisterN >
#+END_SRC

Note that the sequence of Registers does not end with a period because this syntax is not a Statement.

These definitions define the ARBEL language.  ARBEL's environment includes built-in operations to make the language useful for programming.

* Types of Data Literals

Everything in ARBEL is data.  The language is primarily sequences of data.  ARBEL's type system is based on using relatively few, "fixed" data types.  It does not have user-defined types.  Instead, it uses a flexible data structure, called Registries, that can be used to represent complicated data elements built up from the basic types.

This section describes the data types that can be represented as literals.  In later sections, I discuss data types that are only generated by certain operations.

** Numbers

** Strings

** 
** Registers

** Registries





